use clap::{clap_app, ArgMatches};
use std::fs::File;
use std::io::{Error, ErrorKind, Read, Write};
use std::path::Path;
use console::style;
use dialoguer::Confirm;
use std::iter::FromIterator;
use crate::parsing::{parseLine, CodeLine};

mod instruction;
mod parsing;

fn main() {
    let matches = clap_app!(assembler2i =>
        (version: "1.0")
        (author: "Erik Schulze <erikmail3333@gmail.com>")
        (about: "Assembles 2ia files into 2i files")
        (@arg INPUT: +required "Sets the Input File, must have .2ia file Type")
        (@arg OUTPUT: -o +takes_value !required "Sets the Output File, must have .2i file Type")
        (@arg COPY_INSTRUCTIONS: -i !required "Copy Instructions as Comments into the 2i file")
        (@arg COPY_COMMENTS: -c !required "Copy Comments into the 2i file")
    ).get_matches();

    let args = match args_to_program_arguments(matches) {
        Ok(args) => {args},
        Err(error) =>
            {
                eprintln!("{}",style(error).red());
                return;
            }
    };

    let mut files = match open_files(args.input_file_path.as_str(), args.output_file_path.as_str()) {
        Ok(files) => {files},
        Err(error) => {
            eprintln!("{}",style(error).red());
            return;
        }
    };
    let mut input: String = String::new();
    match files.input_file.read_to_string(&mut input) {
        Ok(_) => {},
        Err(_) => {
            eprintln!("{}",style("Error reading Input File").red());
            return;
        }
    }

    let input_lines = input.lines();
    let mut code_lines = Vec::<CodeLine>::new();
    for (i,line) in input_lines.enumerate() {
        let code_line = match parseLine(line) {
            Ok(code_line) => {code_line},
            Err(error) => {
                eprintln!("Error in Line {}, Description: {}", i, error);
                return;
            }
        };
        code_lines.push(code_line);
    }

    let mut output_string = String::new();
    output_string.push_str("# Generated by Assembler2i\r\n");
    output_string.push_str("\r\n");
    for code_line in code_lines {
        output_string.push_str(format!("{}\r\n", code_line).as_str());
    }
    match files.output_file.write_all(output_string.as_bytes()) {
        Ok(_) => {},
        Err(_) => {
            eprintln!("{}", style("Error writing to Output File").red());
            return;
        },
    }
    println!("Successfully translated the Program");
}


struct Files {
    input_file: File,
    output_file: File,
}

fn open_files(input_file_path: &str, output_file_path: &str) -> Result<Files,String> {
    let input_file = match File::open(input_file_path) {
        Ok(file) => {file},
        Err(err) => {
            return match err.kind() {
                ErrorKind::NotFound => { Err("Input File was not found".to_string()) },
                _ => { Err("Could not open Input File".to_string()) }
            }
        }
    };

    if Path::new(output_file_path).exists() {
        match Confirm::new().with_prompt("Output file already exists, overwrite?").interact() {
            Ok(confirm) => {
                if !confirm {
                    return Err("Could not open Output File".to_string())
                }
            },
            Err(_) => {return Err("Could not open Output File".to_string())}
        }
    }

    let output_file = match File::create(output_file_path) {
        Ok(file) => {file},
        Err(_) => {return Err("Could not open Output File!".to_string())},
    };

    return Ok(Files {
        input_file,
        output_file
    });
}

struct ProgramArguments {
    copy_instructions: bool,
    copy_comments: bool,
    input_file_path: String,
    output_file_path: String
}

fn args_to_program_arguments(args: ArgMatches) -> Result<ProgramArguments, String> {
    let copy_instructions = args.is_present("COPY_INSTRUCTIONS");
    let copy_comments = args.is_present("COPY_COMMENTS");

    let input_file_path = match args.value_of("INPUT") {
        None =>
            {
                return Err("Input File was not provided".to_string());
            },
        Some(file_path) => {file_path},
    };
    if !input_file_path.ends_with(".2ia") {
        return Err("Input File does not have .2ia File Type".to_string());
    }
    let mut output_file_path = input_file_path.split_at(input_file_path.len() - 4).0.to_string();
    output_file_path.push_str(".2i");

    match args.value_of("OUTPUT") {
        None => {},
        Some(file_path) => { output_file_path = file_path.to_string()},
    };

    let program_arguments = ProgramArguments {
        copy_instructions,
        copy_comments,
        input_file_path: input_file_path.to_string(),
        output_file_path
    };

    return Ok(program_arguments);
}